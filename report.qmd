---
title: "CVS Health Community Access Analysis"
subtitle: "County-Level Health Needs & Clinic Distribution Report"
author: "Data Analysis Team"
date: today
format:
  pdf:
    documentclass: article
    geometry: margin=1in
    colorlinks: true
    fig-width: 10
    fig-height: 6
    toc: true
    toc-depth: 3
execute:
  echo: true
  warning: false
  message: false
---

```{python}
#| include: false
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from pathlib import Path
import requests
import plotly.express as px

# load data
data_path = Path("data/processed/CVS_FINAL_DATASET.csv")
df = pd.read_csv(data_path)

# clean data
for col in df.columns:
    try:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    except:
        pass

df["COUNTY"] = df["COUNTY"].astype(str).str.zfill(5)

# create health burden score
health_vars = ['stroke', 'physical_inactivity', 'self_care_disability', 'social_isolation']
available_vars = [var for var in health_vars if var in df.columns]
df['health_burden_score'] = df[available_vars].mean(axis=1)

# create normalized scores
# handle case where all values are the same (would cause division by zero)
health_min = df['health_burden_score'].min()
health_max = df['health_burden_score'].max()
if health_max > health_min:
    df['health_need'] = (df['health_burden_score'] - health_min) / (health_max - health_min)
else:
    # if all values are the same, set health_need to 0.5 for all
    df['health_need'] = 0.5
    print("warning: all health burden scores are the same, using default health_need of 0.5")

if df['clinic_count'].max() > 0:
    df['clinic_availability'] = df['clinic_count'] / df['clinic_count'].max()
else:
    df['clinic_availability'] = 0

df['gap_score'] = df['health_need'] - df['clinic_availability']

# load population data if not already in dataset
if 'population' not in df.columns:
    try:
        # census ACS 5-year population variable
        url = "https://api.census.gov/data/2022/acs/acs5?get=NAME,B01003_001E&for=county:*"
        response = requests.get(url, timeout=30)
        data = response.json()
        
        # convert to DataFrame
        pop = pd.DataFrame(data[1:], columns=data[0])
        pop = pop.rename(columns={
            "NAME": "county_name",
            "B01003_001E": "population",
            "state": "state_fips",
            "county": "county_fips"
        })
        
        # create full 5-digit FIPS
        pop["fips"] = pop["state_fips"].astype(str).str.zfill(2) + pop["county_fips"].astype(str).str.zfill(3)
        pop["population"] = pd.to_numeric(pop["population"], errors='coerce')
        pop = pop[['fips', 'population']].drop_duplicates()
        
        # merge with main dataframe
        df['fips'] = df['fips'].astype(str).str.zfill(5)
        pop['fips'] = pop['fips'].astype(str).str.zfill(5)
        
        # check merge success
        before_merge = len(df)
        df = df.merge(pop[['fips','population']], on='fips', how='left')
        after_merge = len(df)
        matched = df['population'].notna().sum()
        
        print(f"population merge: {matched}/{len(df)} counties matched ({matched/len(df)*100:.1f}%)")
        
        # fill missing population values with median to avoid NaN
        if df['population'].isna().any():
            median_pop = df['population'].median()
            if pd.isna(median_pop):
                median_pop = 100000  # fallback if all are NaN
            df['population'] = df['population'].fillna(median_pop)
            print(f"filled {df['population'].isna().sum()} missing population values with median: {median_pop:,.0f}")
        
        print("population data loaded successfully")
    except Exception as e:
        print(f"could not load population data: {e}")
        # use default population for visualization
        df['population'] = 100000
        print("using default population value of 100,000")

# ensure population column exists and has no NaN values
if 'population' not in df.columns:
    df['population'] = 100000
else:
    # fill any remaining NaN values
    if df['population'].isna().any():
        median_pop = df['population'].median()
        if pd.isna(median_pop) or median_pop == 0:
            median_pop = 100000
        df['population'] = df['population'].fillna(median_pop)
        print(f"final check: filled remaining NaN values with {median_pop:,.0f}")

# ensure health_need has no NaN values
if df['health_need'].isna().any():
    df['health_need'] = df['health_need'].fillna(0)

# create population-adjusted gap (ensure no NaN values)
df['pop_adjusted_gap'] = df['health_need'] * df['population']
# replace any NaN or inf values with 0
df['pop_adjusted_gap'] = df['pop_adjusted_gap'].replace([np.inf, -np.inf, np.nan], 0)

print(f"pop_adjusted_gap created: {df['pop_adjusted_gap'].notna().sum()}/{len(df)} valid values")
print(f"pop_adjusted_gap range: {df['pop_adjusted_gap'].min():.0f} to {df['pop_adjusted_gap'].max():.0f}")
```

# Executive Summary

## Key Findings

### Coverage Gap
- **`r round((df['clinic_count'] == 0).sum() / len(df) * 100, 1)`%** of U.S. counties have zero CVS MinuteClinic locations
- Only **`r (df['clinic_count'] > 0).sum()`** counties (**`r round((df['clinic_count'] > 0).sum() / len(df) * 100, 1)`%**) have at least one clinic
- Total clinics across all counties: **`r int(df['clinic_count'].sum())`**

### Socioeconomic Inequity
- Counties without clinics have higher SVI scores: **`r round(df[df['clinic_count']==0]['svi_overall'].mean(), 3)`** vs **`r round(df[df['clinic_count']>0]['svi_overall'].mean(), 3)`**
- Socioeconomic vulnerability: **`r round(df[df['clinic_count']==0]['svi_socioeconomic'].mean(), 3)`** (no clinics) vs **`r round(df[df['clinic_count']>0]['svi_socioeconomic'].mean(), 3)`** (with clinics)

### Health Need Mismatch
- Counties without clinics have higher health burden: **`r round(df[df['clinic_count']==0]['health_burden_score'].mean(), 2)`** vs **`r round(df[df['clinic_count']>0]['health_burden_score'].mean(), 2)`**
- This indicates sicker populations have less access to CVS services

# Key Statistics

## Distribution of Clinic Counts

```{python}
#| fig-cap: "Distribution of CVS clinic counts across all U.S. counties. Most counties have zero clinics."
plt.figure(figsize=(10, 6))
plt.hist(df['clinic_count'], bins=50, edgecolor='black', alpha=0.7, color='steelblue')
plt.axvline(df['clinic_count'].median(), color='red', linestyle='--', linewidth=2, 
            label=f'Median: {df["clinic_count"].median():.1f}')
plt.xlabel('Number of Clinics')
plt.ylabel('Number of Counties')
plt.title('Distribution of Clinic Counts', fontweight='bold')
plt.legend()
plt.grid(alpha=0.3)
plt.show()
```

**what this shows:** the histogram reveals that most counties have zero clinics. the distribution is highly skewed, with a few counties having many clinics while the vast majority have none. this indicates CVS clinics are highly concentrated in specific areas.

## Health Burden Distribution

```{python}
#| fig-cap: "Distribution of health burden scores. Higher scores indicate worse health outcomes."
plt.figure(figsize=(10, 6))
plt.hist(df['health_burden_score'], bins=50, edgecolor='black', alpha=0.7, color='purple')
plt.axvline(df['health_burden_score'].mean(), color='red', linestyle='--', linewidth=2, 
            label=f'Mean: {df["health_burden_score"].mean():.2f}')
plt.axvline(df['health_burden_score'].median(), color='orange', linestyle='--', linewidth=2, 
            label=f'Median: {df["health_burden_score"].median():.2f}')
plt.xlabel('Health Burden Score')
plt.ylabel('Number of Counties')
plt.title('Distribution of Health Burden Scores', fontweight='bold')
plt.legend()
plt.grid(alpha=0.3)
plt.show()
```

**what this shows:** health burden scores are normally distributed with some variation. counties with higher scores have worse health outcomes (more stroke, disability, inactivity, social isolation). comparing this to clinic distribution helps identify underserved areas.

## Clinic Presence vs Health Burden

```{python}
#| fig-cap: "Comparison of health burden scores by clinic presence category."
df['clinic_presence'] = df['clinic_count'].apply(lambda x: 'No Clinics' if x == 0 else ('1-2 Clinics' if x <= 2 else '3+ Clinics'))
comparison_data = df.groupby('clinic_presence')['health_burden_score'].mean()

plt.figure(figsize=(10, 6))
plt.bar(comparison_data.index, comparison_data.values, color=['#d62728', '#ff7f0e', '#2ca02c'])
plt.xlabel('Clinic Presence Category')
plt.ylabel('Average Health Burden Score')
plt.title('Health Burden by Clinic Presence', fontweight='bold')
plt.xticks(rotation=45)
plt.grid(axis='y', alpha=0.3)
plt.show()
```

**what this shows:** counties with no clinics have the highest average health burden (red bar), indicating sicker populations have less access. counties with more clinics tend to have lower health burden, suggesting either better access leads to better health, or clinics are located in healthier areas.

## SVI Quartiles and Clinic Distribution

```{python}
#| fig-cap: "Box plot showing clinic count distribution across SVI quartiles."
df['svi_quartile'] = pd.qcut(df['svi_overall'], q=4, labels=['Low SVI (Q1)', 'Medium-Low SVI (Q2)', 
                                                              'Medium-High SVI (Q3)', 'High SVI (Q4)'])

plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='svi_quartile', y='clinic_count', palette='viridis')
plt.xlabel('SVI Quartile')
plt.ylabel('Number of Clinics')
plt.title('Clinic Count Distribution by Social Vulnerability Index Quartiles', fontweight='bold')
plt.xticks(rotation=45)
plt.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.show()
```

**what this shows:** the box plots reveal that counties in higher SVI quartiles (more vulnerable) tend to have fewer clinics. the median clinic count is zero across all quartiles, but the upper quartiles (outliers) show that some low-vulnerability counties have many clinics, while high-vulnerability counties rarely have clinics.

# Geographic Expansion Opportunities Map

this map shows where CVS should expand by combining health need, social vulnerability, and current clinic access. darker colors indicate higher priority expansion targets.

```{python}
#| fig-cap: "Expansion priority map showing counties by health need, SVI, and clinic access."
# create expansion priority score
# combines health need, SVI, and lack of clinics
# higher score = higher priority for expansion
df['expansion_priority'] = (
    df['health_need'] * 0.4 +  # 40% weight on health need
    df['svi_overall'] * 0.3 +  # 30% weight on vulnerability
    (1 - df['clinic_availability']) * 0.3  # 30% weight on lack of clinics (inverted)
)

# ensure fips codes are properly formatted
df['fips'] = df['fips'].astype(str).str.zfill(5)

# download county boundary data for mapping
try:
    url = "https://raw.githubusercontent.com/plotly/datasets/master/geojson-counties-fips.json"
    counties_geo = requests.get(url, timeout=30).json()
    geo_loaded = True
    print("geographic data loaded successfully")
except Exception as e:
    print(f"could not load geographic data: {e}")
    geo_loaded = False

if geo_loaded:
    # create choropleth map showing expansion priority
    fig = px.choropleth(
        df,
        geojson=counties_geo,
        locations='fips',
        color='expansion_priority',
        color_continuous_scale="Reds",  # red = high priority
        scope="usa",
        labels={'expansion_priority': 'Expansion Priority Score'},
        title="CVS Expansion Priority Map: Health Need + Vulnerability + Access Gap",
        hover_data=['county_full', 'state_full', 'health_burden_score', 'svi_overall', 'clinic_count']
    )
    
    fig.update_geos(fitbounds="locations", visible=False)
    fig.update_layout(height=600, title_font_size=16)
    fig.show()
    
    print("\nâœ“ expansion priority map created")
    print("  darker red = higher priority for expansion")
    print("  priority based on: health need (40%), SVI (30%), lack of clinics (30%)")
    print(f"  priority score range: {df['expansion_priority'].min():.3f} to {df['expansion_priority'].max():.3f}")
else:
    print("geographic data not available - cannot create map")
```

**what this map shows:** 

- **darker red areas**: counties with high expansion priority - these combine high health need, high vulnerability, and low clinic access
- **lighter areas**: counties with lower priority - may have clinics already, lower health needs, or lower vulnerability  
- **hover over counties**: see specific values for health burden, SVI, and clinic count
- **expansion targets**: focus on the darkest red areas where CVS can make the biggest impact
- **geographic patterns**: the map reveals regional clusters of underserved communities (mississippi delta, rural south, etc.)

this map helps visually identify where CVS should prioritize expansion efforts to maximize both business impact and community health outcomes.

# Strategic Recommendations

## Priority 1: High-Impact Urban Expansion
- Focus on large metropolitan counties with high health burden and moderate-to-low clinic density
- Target: Los Angeles County, Harris County (Houston), Dallas County, Maricopa County (Phoenix)
- Rationale: Maximum population impact with existing infrastructure

## Priority 2: Rural High-Need Markets
- Target rural counties with high health burden scores and zero clinics
- Focus on Mississippi Delta, rural South, and Native American communities
- Consider mobile clinics or partnerships with existing healthcare facilities

## Priority 3: Vulnerable Community Access
- Prioritize counties with high SVI scores and zero clinics
- Address socioeconomic barriers to healthcare access
- Consider sliding scale pricing or community health partnerships

## Priority 4: Cluster-Based Expansion
- Use K-means clustering results to identify similar counties
- Develop standardized expansion strategies for each cluster type
- Leverage successful clinic models from similar county types

# Next Steps

1. **Validate Findings**: Cross-reference identified underserved counties with local healthcare infrastructure and competitor presence
2. **Market Research**: Conduct feasibility studies for top-priority expansion targets
3. **Partnership Opportunities**: Explore partnerships with local health systems in underserved areas
4. **Pilot Programs**: Launch pilot clinics in 2-3 high-priority counties to test expansion model
5. **Monitor Impact**: Track health outcomes and utilization rates in new clinic locations
6. **Iterate Strategy**: Use clustering results to refine expansion criteria and identify new opportunities

